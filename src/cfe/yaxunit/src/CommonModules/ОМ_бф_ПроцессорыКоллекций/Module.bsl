// @strict-types


/////////////////////////////////////////////////////////////////////////////////
// Экспортные процедуры и функции, предназначенные для использования другими 
// объектами конфигурации или другими программами
///////////////////////////////////////////////////////////////////////////////// 
#Область СлужебныйПрограммныйИнтерфейс

Процедура ИсполняемыеСценарии() Экспорт
	
	ЮТТесты
		.ДобавитьТест("тест_ИнциализацияИзКоллекции", "Иницилизация из коллекции")
		.ДобавитьТест("тест_ИнциализацияИзНабора", "Инициализация из набора")
		.ДобавитьТест("тест_СтандартнаяСортировка", "Сортировка коллекции")
		.ДобавитьТест("ТестДолжен_ПолучитьРазличныеЭлементыЧерезСтроку", "Выбрать различные")
		.ДобавитьТест("ТестДолжен_ОтфильтроватьЭлементыСПростымИспользованиемПараметров", "Простое использование параметров")
		.ДобавитьТест("ТестДолжен_ОтфильтроватьЭлементыБезИспользованияРезультата", "Фильтрация без использования результата")
	;
		
КонецПроцедуры

#Область События

Процедура ПередВсемиТестами() Экспорт
	
КонецПроцедуры

Процедура ПередКаждымТестом() Экспорт
	
КонецПроцедуры

Процедура ПослеКаждогоТеста() Экспорт
	
КонецПроцедуры

Процедура ПослеВсехТестов() Экспорт
	
КонецПроцедуры

#КонецОбласти

Процедура тест_ИнциализацияИзКоллекции() Экспорт

	Числа = НовыеЧисла();
	Коллекция = бф_ПроцессорыКоллекций.ИзКоллекции(Числа);
	ЮТест.ОжидаетЧто(Коллекция.ВМассив()).Равно(Числа);
	
		
КонецПроцедуры

Процедура тест_ИнциализацияИзНабора() Экспорт

	Числа = НовыеЧисла();
	
	Коллекция = бф_ПроцессорыКоллекций.ИзНабора(
		Числа.Получить(0),
		Числа.Получить(1),
		Числа.Получить(2),
		Числа.Получить(3),
		Числа.Получить(4),
		Числа.Получить(5),
	);
	ЮТест.ОжидаетЧто(Коллекция.ВМассив()).Равно(Числа);
	
		
КонецПроцедуры

Процедура тест_СтандартнаяСортировка() Экспорт

	Числа = НовыеЧисла();
	
	Коллекция = бф_ПроцессорыКоллекций.ИзКоллекции(Числа).Сортировать();
	
	ПредыдущееЗначение = 0;
	
	Для Каждого Элемент Из Коллекция.ВМассив() Цикл
		ЮТест.ОжидаетЧто(ПредыдущееЗначение).МеньшеИлиРавно(Элемент);
		//@skip-check statement-type-change
		ПредыдущееЗначение = Элемент;
	КонецЦикла;
	
КонецПроцедуры

Процедура ТестДолжен_ПолучитьРазличныеЭлементыЧерезСтроку() Экспорт
	
	ПроцессорКоллекций = бф_ПроцессорыКоллекций.ИзНабора(2, 1, 4, 1, 0, 3);
	Результат = ПроцессорКоллекций
		.Различные("Результат = Элемент1 = Элемент2")
		.ВМассив();
	ЮТест.ОжидаетЧто(Результат).ИмеетДлину(5)
		.Элемент(0).Равно(2)
		.Элемент(1).Равно(1)
		.Элемент(2).Равно(4)
		.Элемент(3).Равно(0)
		.Элемент(4).Равно(3)
	;	
КонецПроцедуры

Процедура ТестДолжен_ОтфильтроватьЭлементыСПростымИспользованиемПараметров() Экспорт
	МаксимальноеЗначение = 2;

	ПроцессорКоллекций = бф_ПроцессорыКоллекций.ИзНабора(2, 1, 4, 1, 0, 3);
	Результат = ПроцессорКоллекций
		.Фильтровать("Результат
			|	= Элемент < МаксимальноеЗначение", // заодно проверяется перенос строк
			Новый Структура("МаксимальноеЗначение", МаксимальноеЗначение))
		.ВМассив();
	Для Каждого Элемент Из Результат Цикл
		ЮТест.ОжидаетЧто(Элемент).Меньше(МаксимальноеЗначение);
	КонецЦикла;
КонецПроцедуры

Процедура ТестДолжен_ОтфильтроватьЭлементыБезИспользованияРезультата() Экспорт
	МаксимальноеЗначение = 2;

	ПроцессорКоллекций = бф_ПроцессорыКоллекций.ИзНабора(2, 1, 4, 1, 0, 3);
	Результат = ПроцессорКоллекций
		.Фильтровать("Элемент < МаксимальноеЗначение",
			Новый Структура("МаксимальноеЗначение", МаксимальноеЗначение))
		.ВМассив();
	Для Каждого Элемент Из Результат Цикл
		ЮТест.ОжидаетЧто(Элемент).Меньше(МаксимальноеЗначение);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция НовыеЧисла()
	Массив = Новый Массив; // Массив из Число
	Массив.Добавить(1);
	Массив.Добавить(5);
	Массив.Добавить(2);
	Массив.Добавить(92);
	Массив.Добавить(7);
	Массив.Добавить(2);
	
	Возврат Массив;
	
КонецФункции

#КонецОбласти
